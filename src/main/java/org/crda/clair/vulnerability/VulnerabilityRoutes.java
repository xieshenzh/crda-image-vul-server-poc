package org.crda.clair.vulnerability;

import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;
import org.apache.camel.Exchange;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.processor.aggregate.GroupedBodyAggregationStrategy;
import org.crda.clair.cache.model.Image;
import org.crda.clair.cache.model.Vulnerability;
import org.crda.image.ImageDigestProcessor;

import java.util.*;
import java.util.stream.Collectors;

import static org.apache.camel.Exchange.CONTENT_TYPE;
import static org.apache.camel.Exchange.HTTP_RESPONSE_CODE;
import static org.apache.camel.builder.endpoint.StaticEndpointBuilders.direct;
import static org.apache.camel.builder.endpoint.StaticEndpointBuilders.seda;
import static org.apache.camel.support.builder.PredicateBuilder.or;
import static org.crda.image.Constants.digestsHeader;
import static org.crda.image.Constants.imageRefHeader;
import static org.crda.clair.vulnerability.Constants.digestsNotFoundHeader;
import static org.crda.clair.vulnerability.Constants.scannedHeader;

@ApplicationScoped
public class VulnerabilityRoutes extends RouteBuilder {

    public VulnerabilityRoutes() {
    }

    @Inject
    VulnerabilityIdempotentRepository idempotentRepository;

    @Override
    public void configure() throws Exception {
        onException(RuntimeException.class)
                .handled(true)
                .setHeader(HTTP_RESPONSE_CODE, constant(500))
                .setHeader(CONTENT_TYPE, constant("text/plain"))
                .setBody().simple("${exception.message}");

        from(direct("getClairVulnerabilities"))
                .to(direct("parseImageName"))
                .to(direct("getImageManifests"))
                .to(direct("checkImageFound"))
                .to(direct("queryClairVulnerabilityData"))
                .to(direct("checkClairVulnerabilityData"))
                .to(direct("clairScanImagesVulnerability"));

        from(direct("queryClairVulnerabilityData"))
                .split(body(), new GroupedBodyAggregationStrategy())
                .stopOnException()
                .parallelProcessing()
                .process(new ImageDigestProcessor())
                .setBody(header(imageRefHeader))
                .to(direct("findClairImageVulnerabilities"))
                .end()
                .choice()
                .when(or(body().isNull(), bodyAs(List.class).method("isEmpty").isEqualTo(true)))
                .process(exchange -> {
                    List<?> digests = exchange.getIn().getHeader(digestsHeader, List.class);
                    exchange.getIn().setHeader(digestsNotFoundHeader, digests);
                })
                .otherwise()
                .setBody(exchange -> {
                    List<?> results = exchange.getIn().getBody(List.class);

                    Set<String> digestSet = results.stream()
                            .filter(e -> e instanceof Image)
                            .map(e -> ((Image) e))
                            .map(Image::getDigest)
                            .collect(Collectors.toSet());

                    List<?> digests = exchange.getIn().getHeader(digestsHeader, List.class);
                    List<?> digestsMissing = digests.stream().filter(d -> !digestSet.contains(d)).toList();
                    exchange.getIn().setHeader(digestsNotFoundHeader, digestsMissing);

                    Map<String, Vulnerability> vulnerabilityMap = results.stream()
                            .filter(e -> e instanceof Image)
                            .map(e -> ((Image) e))
                            .map(Image::getVulnerabilities)
                            .filter(Objects::nonNull)
                            .flatMap(Collection::stream)
                            .collect(Collectors.toMap(Vulnerability::getId,
                                    v -> v,
                                    (k1, k2) -> k1));
                    return vulnerabilityMap.values();
                })
                .endChoice();

        from(direct("checkClairVulnerabilityData"))
                .process(exchange -> {
                    List<?> digests = exchange.getIn().getHeader(digestsHeader, List.class);
                    List<?> digestsNotFound = exchange.getIn().getHeader(digestsNotFoundHeader, List.class);
                    if (digestsNotFound == null || digestsNotFound.isEmpty()) {
                        exchange.getIn().setHeader(scannedHeader, "true");
                    } else if (new HashSet<>(digestsNotFound).containsAll(digests)) {
                        exchange.getIn().setHeader(scannedHeader, "false");
                    } else {
                        exchange.getIn().setHeader(scannedHeader, "partial");
                    }
                })
                .choice()
                .when(header(scannedHeader).isEqualTo("false"))
                .setHeader(Exchange.HTTP_RESPONSE_CODE, constant(202))
                .setHeader(Exchange.CONTENT_TYPE, constant("text/plain"))
                .setBody(constant("Image scan is in process. Please try again later."))
                .when(header(scannedHeader).isEqualTo("partial"))
                .setHeader(Exchange.HTTP_RESPONSE_CODE, constant(202))
                .endChoice();

        from(direct("clairScanImagesVulnerability"))
                .choice()
                .when(header(digestsNotFoundHeader).isNotNull())
                .split(header(digestsNotFoundHeader))
                .parallelProcessing()
                .process(new ImageDigestProcessor())
                .setBody(header(imageRefHeader))
                .to(seda("clairScanImage?concurrentConsumers=1&waitForTaskToComplete=Never&timeout=0"))
                .end()
                .endChoice();

        from(seda("clairScanImage?concurrentConsumers=1&waitForTaskToComplete=Never&timeout=0"))
                .idempotentConsumer(body()).idempotentRepository(idempotentRepository)
                .to(direct("clairReport"))
                .convertBodyTo(Image.class)
                .to(direct("saveClairImageVulnerabilities"));
    }
}
